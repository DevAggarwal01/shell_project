                        +--------------------+
                        |        CS 439      |
                        |  PROJECT 0: SHELL  |
                        |   DESIGN DOCUMENT  |
                        +--------------------+




The questions in this design document should reflect the design of the code you
wrote for the project.  Your grade will reflect both the quality of your answer
in this document and the quality of the design implementation in your code. 
If there is a portion of the project that you have not implemented, you cannot
receive credit for related questions. For those questions, no response is 
necessary beyond indicating that you did not implement that portion.


For each question, you should include both the name of the file(s), function
name(s), and the line numbers where the relevant code may be found---both the
code that answers the question directly and any function that you refer to in
your answer.


These design documents will be completed and submitted as a group.  Please use
this document as a guide for design and discuss the questions and their
potential answers prior to beginning implementation.


When you have completed your design document, submit it to the Canvas assignment
Project 0 Design and Documentation.


***Your submission must be a text file and each line must not extend pat 80
characters.  In addition, your submission must contain all of the original
material and not exceed 8,000 characters.  The character count will be measured
using the Linux command wc.  (Note that rtf files are NOT text files.) 


################
TEAM INFO
################
Name: Dev Aggarwal
EID: da34882
CS login: dev4dev
Email: dev4dev@cs.utexas.edu
Unique Number: 54895


Name: Hrutvik Rao Palutla Venkata
EID: hp22429
CS login: hrutvikp
Email: hrutvikp@cs.utexas.edu
Unique Number: 54905



Slip Days Used: 0


################
Preliminaries
################
(1) If you have any preliminary comments on your submission or notes for
    the TA, please give them here.  If you did not implement all portions
    of this project, that should be noted here.

    N/A, there are no special considerations here - did not change most of 
    the provided files and implemented everything.


(2) Please cite any offline or online sources you consulted while
    preparing your submission, other than the Linux documentation,
    course text, and lecture notes.

    Only the project webpage and the provided reading in the project webpage.


(3) Please paste a link to your GitLab repo below.
https://github.com/DevAggarwal01/shell_project.git

################
Questions regarding Part 0
################
(1) How many child processes are created when doFib() 
    begins with an input of 5?  Show the return value for 
    each child process, numbering the processes beginning 
    with 0 (the original process) and incrementing for
    each child process.

    There are 15 child processes created. All child process return with exit status.
    Process 0:  doFib(5, 1) = 5 (prints result here)
    Process 1:  doFib(3, 0) = 2
    Process 2:  doFib(1, 0) = 1
    Process 3:  doFib(1, 0) = 1
    Process 4:  doFib(0, 0) = 0
    Process 5:  doFib(0, 0) = 1
    Process 6:  doFib(3, 0) = 3
    Process 7:  doFib(2, 0) = 1
    Process 8:  doFib(0, 0) = 0
    Process 9:  doFib(0, 0) = 1
    Process 10: doFib(2, 0) = 2
    Process 11: doFib(1, 0) = 1
    Process 12: doFib(1, 0) = 1
    Process 13: doFib(0, 0) = 0
    Process 14: doFib(0, 0) = 1

(2) Explain how you communicated the return value of the 
    child to the parent. What feature of wait() did you use?

    In fib.c's doFib method, the parent processes use waitpid in lines 79 and 94
    to wait for the child processes. When the child process dies, the fibonnaci
    number calculated by the child process is passed in as the status code parameter 
    of the exit call (lines 104 and 64). The status code is retrieved via waitpid and 
    extracted using the WEXITSTATUS macro (lines 80 and 94).

################
Questions regarding Part 1
################
(1) In the provided utility function signal_action(), what does the call to
  sigaction() do?  Why was sigaction() used instead of signal()?

    sigaction() replaces the old handler for the specified signal with a handler provided
    by the user. sigaction() is used instead of signal() because signal() automatically 
    resets the handler after it runs once. Since CTRL+C may be pressed multiple times 
    during the infinite loop, signal() cannot be used since the handler would certainly 
    reset after 1 runthrough.

################
Questions regarding Part 2
################
(1) What combination of structs, arrays, and other data structures 
    did you use to represent a fully-parsed command? Pick another 
    (reasonable) representation you could have used, and give one advantage 
    and one disadvantage of the representation you chose to implement in
    comparison to the data structure you chose here.

    Note that you do not need to include concurrent commands in your answer. 
    Part 2 does not include this advanced shell feature.

To represent the fully-parsed command struct, we used an array of char pointers
to store the program and its arguments, and a char pointer to the program command 
for convenience.

An alternate data structure that can be used is linked list. One advantage in using
a linked list for arguments is that the shell never requests more data via malloc
than is needed for each command line entered by the user. This is in contrast to the
current implementation in line 185 that requests the maximum amount of bytes that 
could possibly be in a command line every single time. The disadvantage is that system calls
expect an array not a linked list, so all data in the linkedlist would need to be copied over to an
array and freed after the system call. Another disadvantage is that calling malloc for every single
token would result in a higher volume of malloc calls so there is higher overhead.


(2) An invalid script file is one which does not contain anything (i.e. 
    a size zero file). How did you detect and handle this condition?  
    Describe one other (correct) design that you could have used.

If the code runs a script file, then it initally retrieves the 1st character 
via fgetc at line 69. If the return value from fgetc is equal to the EOF macro (-1),
then the script file is invalid. 

An alternate approach is to examine what is returned by the 1st getline call.
If the returned value is -1, then it is an empty file.

################
Questions regarding Part 3
################
(1) Describe how your implementation ensures that concurrent
    commands are executed concurrently instead of one after 
    another.

If a command line contains multiple concurrent commands, then each command is parsed
into separate command structs. There is a for loop on line 126 of utsch.c that is iterating
through each command, and calling eval(). Even though a for loop exists, eval() triggers
exec_external_cmd() which forks on line 407. So while the child process is executing a command,
the parent process returns to the for loop iterating over the command and concurrently calls
eval() again. Then, the parent waits for all the concurrent commands to finish in the for loop



(2) One potential strategy for redirecting output is to run 
    the following code:

  ```
  FILE* output = fopen(filename, "w");
  stdout = output;
  stderr = output;
  ```

  This causes everything that would normally be written to 
  `stdout` to instead be written to the file described by 
  filename. Unfortunately, this strategy does not work for 
  output redirection in utcsh. More generally, it does not
  work any time fork-and-exec is used and we want to 
  redirect the output of the child process.

  Explain why this technique does not work when used in 
  conjunction with fork-and-exec, and why the dup2() 
  technique does not suffer the same issue.

fopen() contains a close-on-exec flag, such that when exec() runs,
the file descriptor is discarded which is why it will not work in fork-and-exec.
dup2() copies the incoming file descriptor, but turns the close-on-exec flag off
so the output redirection will work in fork-and-exec.

